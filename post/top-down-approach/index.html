<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Компьютерные сети. Нисходящий подход, Джеймс Куроуз, Кит Росс &nbsp; </title>

  
  <link rel="stylesheet" href="https://bege13mot.github.io/css/poole.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/highlight/sunburst.css">
  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://bege13mot.github.io/touch-icon-144-precomposed.png">
  <link href="/icon/fox.png" rel="icon">

  
  
  
  

  <meta name="description" content="">
  <meta name="keywords" content="">
  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <a href="https://bege13mot.github.io/">
        <img src="/icon/fox.png" alt="avatar" title="">
        </a>
      
      <h1></h1>
      
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/">Home</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/tags/">Tags</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/categories/">Categories</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/about/">About</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/Bege13mot"><img src="/icon/github.svg" class="fa"></img></a>
      <a href="https://www.goodreads.com/user/show/5520080-ivan"><img src="/icon/goodreads.svg" class="fa"></img></a>
      <a href="mailto:bege13mot@gmail.com"><img src="/icon/mail.svg" class="fa"></img></a>
      <a href="https://ru.linkedin.com/in/voronchihin"><img src="/icon/linkedin.svg" class="fa"></img></a>      
      <a href="https://bege13mot.github.io/index.xml" type="application/rss+xml"><img src="/icon/rss.svg" class="fa"></img></a>
      </li>
    </ul>

    

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1>Компьютерные сети. Нисходящий подход, Джеймс Куроуз, Кит Росс</h1>
    <span class="post-date">Apr 16, 2017 &middot; 9 minute read &middot; <a href="https://bege13mot.github.io/post/top-down-approach/#disqus_thread">Comments</a>
    </span>
    <p>
        
    <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
    
    
    Tag:    
    <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/theory">theory</a><a class="label" href="https://bege13mot.github.io/tags/it">it</a>
    </p>
    <p><img src="/img/2017/cn-top-down.jpg" alt="image"></p>
<p>Пожалуй, идеальная книга для знакомства с сетями. В отличие от <a href="https://bege13mot.github.io/post/%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B5-%D1%81%D0%B5%D1%82%D0%B8-%D1%8D%D0%BD%D0%B4%D1%80%D1%8E-%D1%82%D0%B0%D0%BD%D0%B5%D0%BD%D0%B1%D0%B0%D1%83%D0%BC/">Компьютерных сетей, Эндрю Таненбаума</a>, здесь упор на практические примеры. Зачем это нужно, как оно помогает решать конкретную задачу. И почти никой теории, в отличии от Таненбаума. Что как раз прекрасно подходит для новичков. А еще в книге есть великолепная глава о том, что происходит при наборе google.com в браузере с точки зрения сети. Со всеми подробностями.</p>
<h4 id="заметки">Заметки:</h4>
<ul>
<li>
<p>В контексте IP-протокола принято говорить, что подобная сеть, соединяющая три интерфейса хост-машин и один интерфейс маршрутизатора, представляет собой подсеть. В технической литературе по Интернету подсеть также иногда называется IP-сеть или просто сеть. В ходе IP- адресации данной подсети присваивается адрес 223.1.1.0/24. Часть адреса /24, иногда называемая маской подсети, указывает, что 24 крайних левых разряда 32-разрядного значения определяют адрес подсети. Соответственно, подсеть 223.1.1.0/24 состоит из трех интерфейсов хостов (223.1.1.1, 223.1.1.2 и 223.1.1.3) и одного интерфейса маршрутизатора (223.1.1.4). Любые дополнительные хосты, подключаемые к подсети 223.1.1.0/24, обязательно должны будут иметь адреса вида 223.1.1.xxx.</p>
</li>
<li>
<p>При передаче дейтаграмм используются и адреса сетевого уровня (например, IP-адреса Интернета), и адреса канального уровня (то есть MAC-адреса), поэтому возникает потребность в преобразовании одних адресов в другие. В Интернете эту работу выполняет протокол разрешения адресов (Address Resolution Protocol, ARP)&hellip; Итак, ARP-модуль преобразует IP-адрес в MAC-адрес узла. Во многом это аналогично системе DNS, преобразующей имена хостов в IP-адреса.</p>
</li>
<li>
<p>Ретроспектива: один день из жизни запроса веб-страницы
*
* <strong>Начало: DHCP, UDP, IP и Ethernet</strong></p>
<ol>
<li>
<p>Операционная система на ноутбуке Боба создает сообщение с запросом DHCP и записывает это сообщение в UDP-сегмент. В качестве порта получателя указывается порт 67 (DHCP-сервер), а порт отправителя имеет номер 68 (DHCP-клиент). После этого UDP-сегмент записывается в IP дейтаграмму с широковещательным IP-адресом получателя (255.255.255.255). IP-адрес отправителя будет равен 0.0.0.0, так как у ноутбука Боба еще нет IP-адреса.</p>
</li>
<li>
<p>IP-дейтаграмма, содержащая сообщение с запросом DHCP, затем помещается в Ethernet-кадр. Ethernet-кадр обладает MAC- адресами назначения FF:FF:FF:FF:FF:FF, поэтому кадр будет широковещательно передаваться всем устройствам, подключенным к коммутатору (остается надеяться, что среди этих устройств окажется и DHCP-сервер). Исходный MAC-адрес кадра совпадает с адресом ноутбука Боба, 00:16:D3:23:68:8A.</p>
</li>
<li>
<p>Широковещательный Ethernet-кадр, содержащий DHCP-запрос — это первый кадр, отправленный ноутбуком Боба на Ethernet- коммутатор. Коммутатор широковещательно передает этот входящий кадр на все свои выходные порты, в том числе на порт, подключенный к маршрутизатору.</p>
</li>
<li>
<p>Маршрутизатор получает широковещательный Ethernet-кадр с DHCP- запросом на интерфейс с MAC-адресом 00:22:6B:45:1F:1B, после чего IP-дейтаграмма извлекается из Ethernet-кадра. Широковещательный IP-адрес назначения дейтаграммы указывает, что IP-дейтаграмма должна быть обработана на данном узле более высокоуровневыми протоколами, поэтому полезная нагрузка дейтаграммы (UDP-сегмент) демультиплексируется вплоть до UDP, а сообщение с запросом DHCP извлекается из UDP-сегмента. Итак, теперь у DHCP-сервера есть сообщение с запросом DHCP.</p>
</li>
<li>
<p>Предположим, что DHCP-сервер, работающий на маршрутизаторе, может выделять адреса из блока CIDR 68.85.2.0/24. Таким образом, в данном примере все IP-адреса университета будут относиться к блоку адресов провайдера Comcast. Далее допустим, что DHCP-сервер выделяет ноутбуку Боба адрес 65.85.2.101. DHCP-сервер создает сообщение DHCP ACK, в котором содержится этот IP-адрес, а также следующая информация: IP-адрес DNS-сервера (68.87.71.226), IP-адрес шлюзового маршрутизатора, задаваемого по умолчанию (68.85.2.1) и, наконец, блок подсети (65.85.2.0/24), он же — «маска сети». DHCP-сообщение записывается в UDP-сегмент, который заключается в IP-дейтаграмму, а она, в свою очередь — в Ethernet-кадр. Ethernet-кадр располагает исходным MAC-адресом (это адрес интерфейса маршрутизатора, соединяющего маршрутизатор с домашней сетью — 00:22:6B:45:1F:1B) и конечным MAC-адресом (это адрес ноутбука Боба 00:16:D3:23:68:8A).</p>
</li>
<li>
<p>Ethernet-кадр, содержащий сообщение DHCP ACK (одноадресно), передается маршрутизатором на коммутатор. Поскольку коммутатор является самообучающимся, а ранее получил Ethernet-кадр (с DHCP-запросом) с ноутбука Боба, коммутатору уже известно, что кадр, идущий на адрес 00:16:D3:23:68:8A, нужно просто передать на выходной порт, ведущий к ноутбуку Боба.</p>
</li>
<li>
<p>Ноутбук Боба получает сообщение DHCP ACK, извлекает IP-дейтаграмму из Ethernet-кадра, затем UDP-сегмент из IP-дейтаграммы, после чего — сообщение DHCP ACK из UDP-сегмента. Затем DHCP-клиент с ноутбука Боба записывает его IP-адрес, а также IP-адрес его DNS-сервера. Кроме того, он заносит адрес в свою IP- таблицу маршрутизации. Ноутбук Боба будет отсылать на заданный по умолчанию шлюз все дейтаграммы, чей адрес назначения находится вне его подсети 68.85.2.0/24. На данном этапе ноутбук Боба уже инициализировал свои сетевые компоненты и готов обрабатывать операции выборки веб-страниц.</p>
<ul>
<li><strong>Начало продолжается: DNS и ARP</strong></li>
</ul>
</li>
<li>
<p>Когда Боб вводит в браузер адрес <a href="https://www.google.com">www.google.com</a>, начинается длинная цепочка событий. Ее конечный результат — отображение главной страницы Google в браузере. Для этого операционная система на ноутбуке Боба создает сообщение с запросом DNS, помещая строку «www.google.com» в тот раздел DNS-сообщения, где содержится запрос. Затем это DNS-сообщение записывается в UDP-сегмент с портом назначения 53 (это DNS-сервер). После этого данный UDP-сегмент помещается в IP-дейтаграмму, имеющую IP-адрес получателя 68.87.71.226 (это адрес DNS-сервера, который мы приняли в возвращенном сообщении DHCP ACK на этапе 5) и IP-адрес отправителя 68.85.2.101.</p>
</li>
<li>
<p>После этого ноутбук Боба помещает дейтаграмму, содержащую сообщение с запросом DNS, в Ethernet-кадр. Этот кадр будет отправлен (адресован на сетевом уровне) на шлюзовой маршрутизатор сети того университета, где учится Боб. Однако, хотя ноутбуку Боба и известен IP-адрес шлюзового маршрутизатора университета (65.85.2.1) — эта информация была получена в сообщении DHCP ACK на этапе 5, описанном выше, ему не известен MAC-адрес этого шлюза. Чтобы получить MAC-адрес шлюзового маршрутизатора, на ноутбуке Боба понадобится задействовать протокол ARP.</p>
</li>
<li>
<p>Ноутбук Боба создает сообщение с запросом ARP, где указывается целевой IP-адрес 68.85.2.1 (адрес шлюзового маршрутизатора). ARP-сообщение помещается в Ethernet-кадр с широковещательным адресом получателя (FF:FF:FF:FF:FF:FF), после чего ноутбук отправляет Ethernet-кадр на коммутатор, который, в свою очередь, доставляет этот кадр на все подключенные к нему устройства, в том числе на шлюзовой маршрутизатор.</p>
</li>
<li>
<p>Шлюзовой маршрутизатор получает кадр с сообщением c ARPзапросом на интерфейс, ведущий в него из университетской сети, и определяет, что целевой IP-адрес 68.85.2.1 в ARP-сообщении совпадает с IP-адресом его интерфейса. После этого шлюзовой маршрутизатор подготавливает ARP-ответ, указывая, что его MAC-адрес 00:22:6B:45:1F:1B соответствует IP-адресу 68.85.2.1. Сообщение с ARP-ответом записывается в Ethernet-кадр с адресом получателя (это ноутбук Боба). После этого кадр отправляется на коммутатор, который доставляет его на ноутбук Боба.</p>
</li>
<li>
<p>Ноутбук Боба получает кадр с ответным ARP-сообщением и извлекает MAC-адрес шлюзового маршрутизатора (00:22:6B:45:1F:1B) из этого сообщения.</p>
</li>
<li>
<p>Теперь ноутбук Боба (наконец-то!) может отправить Ethernet-кадр с DNS-запросом на MAC-адрес шлюзового маршрутизатора. Обратите внимание: IP-дейтаграмма в этом кадре имеет IP-адрес получателя 68.87.71.226 (это адрес DNS-сервера), тогда как адрес получателя кадра — 00:22:6B:45:1F:1B (это шлюзовой маршрутизатор). Ноутбук Боба отправляет кадр на коммутатор, который, в свою очередь, доставляет этот кадр на шлюзовой маршрутизатор.</p>
<ul>
<li><strong>Начало продолжается: внутридоменная маршрутизация на DNS-сервер</strong></li>
</ul>
</li>
<li>
<p>Шлюзовой маршрутизатор получает кадр и извлекает из него IP- дейтаграмму, содержащую DNS-запрос. Маршрутизатор уточняет адрес назначения этой дейтаграммы (68.87.71.226) и определяет по своей таблице маршрутизации, что дейтаграмма должна быть отправлена на маршрутизатор сети Comcast. IP-дейтаграмма помещается в кадре канального уровня для перемещения по каналу, который связывает университетский маршрутизатор с маршрутизатором Comcast. Кадр отправляется по этому каналу.</p>
</li>
<li>
<p>Вышеупомянутый маршрутизатор из сети Comcast получает кадр, извлекает IP-дейтаграмму, проверяет ее адрес получателя (68.87.71.226), а потом по своей таблице маршрутизации определяет выходной интерфейс, через который этот кадр должен быть отправлен на DNS-сервер. Таблица маршрутизации была заполнена при помощи протокола внутридоменной маршрутизации сети Comcast (это может быть протокол RIP, OSPF или IS-IS), а также с применением протокола BGP, обеспечивающего междоменную маршрутизацию в Интернете.</p>
</li>
<li>
<p>Наконец, IP-дейтаграмма, содержащая DNS-запрос, прибывает на DNS-сервер. DNS-сервер извлекает сообщение с DNS-запросом, ищет в своей базе данных DNS адрес <a href="https://www.google.com">www.google.com</a>, после чего находит запись DNS-ресурса, содержащую IP-адрес (64.233.169.105) сайта <a href="https://www.google.com">www.google.com</a> (предполагается, что эта запись уже кэширована на DNS-сервере). Как вы помните, эти кэшированные данные берутся с авторитетного DNS-сервера, отвечающего за сайт google.com. Сервер формирует ответное DNS-сообщение, в котором содержится отображение данного хост-имени на соответствующий IP-адрес, и помещает это ответное сообщение в UDP-сегмент. Сегмент, находящийся в IP-дейтаграмме, адресуется на ноутбук Боба (68.85.2.101). Эта дейтаграмма будет отправлена обратно в сеть Comcast, а оттуда далее, через Ethernet-коммутатор на ноутбук Боба.</p>
</li>
<li>
<p>Ноутбук Боба извлекает IP-адрес сервера <a href="https://www.google.com">www.google.com</a> из DNS-сообщения. Наконец, проделав всю эту огромную работу, ноутбук Боба готов подключиться к серверу <a href="https://www.google.com">www.google.com</a>!</p>
<ul>
<li><strong>Клиент-серверное взаимодействие: TCP и HTTP</strong></li>
</ul>
</li>
<li>
<p>Теперь, когда ноутбук Боба обладает IP-адресом <a href="https://www.google.com">www.google.com</a>, он может создать TCP-сокет, который будет использоваться для отправки сообщения HTTP GET на сайт www. google.com. Когда Боб создает TCP-сокет, протокол TCP в ноутбуке Боба сперва должен выполнить тройное рукопожатие с протоколом TCP на <a href="https://www.google.com">www.google.com</a>. Поэтому для начала ноутбук Боба создает сегмент TCP SYN с портом назначения 80 (для HTTP), помещает TCP-сегмент в IP-дейтаграмме, задавая IP-адрес получателя 64.233.169.105 (<a href="https://www.google.com">www.google.com</a>). Эта дейтаграмма помещается в кадр с MAC-адресом получателя 00:22:6B:45:1F:1B (шлюзовой маршрутизатор). После всех этих операций кадр отправляется на коммутатор.</p>
</li>
<li>
<p>Маршрутизаторы из университетской сети, сети Comcast и сети Google шлют дейтаграмму с пакетом TCP SYN на адрес www.google. com. Для этого используются таблицы маршрутизации каждого из них, как описано выше в шагах 14-16. Как вы помните, записи в таблицах маршрутизации, управляющие перемещением пакетов по междоменным связям между сетями Comcast и Google, формируются протоколом BGP.</p>
</li>
<li>
<p>Наконец, дейтаграмма с пакетом TCP SYN прибывает на www. google.com. Там сообщение TCP SYN извлекается из дейтаграммы и демультиплексируется на нужный сокет, ассоциированный с портом 80. Специальный сокет соединения создается для установления соединения между HTTP-сервером Google и ноутбуком Боба по протоколу TCP. Генерируется сегмент TCP SYNACK, затем этот сегмент помещается в дейтаграмме, адресованной на ноутбук Боба, и, наконец, заключается в кадре канального уровня, подходящем для передачи по каналу, соединяющему www. google.com и его первый транзитный маршрутизатор.</p>
</li>
<li>
<p>Дейтаграмма, содержащая сегмент TCP SYNACK, направляется через сети Google, Comcast и университета, в итоге оказываясь на сетевой Ethernet-карте ноутбука Боба. Дейтаграмма демультиплексируется в операционной системе на TCP-сокет, созданный в шаге 18, и этот сокет переходит в соединенное состояние.</p>
</li>
<li>
<p>Когда сокет на ноутбуке Боба (наконец-то!) готов отправлять байты на <a href="https://www.google.com">www.google.com</a>, браузер на ноутбуке создает сообщение с запросом HTTP GET, содержащее адрес URL, откуда требуется взять данные. Затем сообщение HTTP GET записывается на сокет, причем запрос GET становится полезным содержимым TCPсегмента. TCP-сегмент помещается в дейтаграмму, отправляется и доставляется на сайт <a href="https://www.google.com">www.google.com</a>, как описано в шагах 18–20 выше.</p>
</li>
<li>
<p>HTTP-сервер по адресу <a href="https://www.google.com">www.google.com</a> считывает сообщение HTTP GET с TCP-сокета, создает HTTP-ответ (раздел 2.2), помещает контент запрошенной веб-страницы в тело ответного HTTP-сообщения, после чего отправляет это сообщение на TCP-сокет.</p>
</li>
<li>
<p>Дейтаграмма, содержащая HTTP-ответ, направляется через сети Google, Comcast и университетскую сеть, после чего прибывает на ноутбук Боба. Браузер на ноутбуке считывает HTTP-сообщение с сокета, извлекает html-код веб-страницы из тела HTTP-ответа и (наконец-то!) отображает веб-страницу.</p>
</li>
</ol>
</li>
<li>
<p>Чтобы решить проблему доставки огромных потоков данных пользователям из разных стран, почти все крупные компании используют сети распространения контента (Content Distribution Network, CDN). Сеть CDN состоит из множества размещенных в разных местах серверов, в которых хранятся видеофайлы (и другие веб-ресурсы, такие как документы, изображения и аудиоданные); каждый пользователь перенаправляется в ту точку сети, которая является для него наиболее подходящей. CDN может принадлежать одной компании, предоставляющей данные (как в случае с компанией Google, которая распространяет видеоролики и другие данные через сервис YouTube), или использоваться сразу нескольки- ми провайдерами (например, компания Akamai предоставляет CDN для многих сервисов, в том числе для Netflix и Hulu)&hellip; Большинство сетей CDN выполняют перехват и перенаправление на уровне DNS.</p>
</li>
<li>
<p>Важная область практического применения цифровых подписей — это сертификация с открытым ключом. Такая сертификация удостоверяет, что открытый ключ принадлежит конкретному лицу.Сертификация с открытым ключом применяется во многих популярных сетевых протоколах — в частности, в IPsec и SSL.</p>
</li>
<li>
<p>Чтобы решить проблему неэффективности, будем использовать сеансовый ключ. Во-первых, Алиса случайным образом выбирает симметричный сеансовый ключ KS, во-вторых, зашифровывает этим ключом KS свое сообщение m, в-третьих, зашифровывает сеансовый ключ KS открытым ключом Боба K+B, в-четвертых, формирует из всех зашифрованных данных один пакет и, в-пятых, посылает этот пакет по адресу электронной почты Боба. Получив сообщение, Боб, во-первых, с помощью своего закрытого ключа K–B получает сеансовый ключ KS, во-вторых, с помощью сеансового ключа сеанса KS расшифровывает сообщение m.</p>
</li>
</ul>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "bege13mot";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "bege13mot";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script src="https://bege13mot.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
  var _gaq=[['_setAccount','UA-73422311-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>

